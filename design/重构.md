### 什么是重构
所谓的重构是指这样一个过程：在不改变代码外在行为的前提下，对代码作出修改，以改进程序的内部结构。其实就是改进原有代码的设计

### 重构的目的
1. 重构改进软件的设计。当人们只为了短期目的而修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构，于是设计就逐渐腐败变质。重构有助于代码维持自己该有的形态
2. 重构使软件更容易理解。编程的核心在于“准确地说出我想要的”，重构可以让代码更好地表达自己的意图
3. 重构帮助找到bug。对代码进行重构，可以深入理解里面的所作所为，从而更有效地写出健壮代码
4. 重构提高编程速度。通过投入精力改善内部设计，增加了软件的耐久性，从而可以更长时间地保持开发的快速

总结：重构可以改善设计、提升可读性、减少bug、快速开发，也就是说，重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值

### 何时重构
1. 预备性重构，让添加新功能更容易。重构的最佳时机就在添加新功能之前
2. 帮助理解的重构。一旦需要思考“这段代码到底在做什么”，那么就要自问能不能重构这段代码了
3. 捡垃圾式重构。每次把“垃圾”清理一点，积少成多，“垃圾”总会被清理干净的
4. 复审代码时重构。

### 重构的步骤
1. 只需要把某个字段从一个类移到另一个类
2. 把某些代码从一个函数移到另一个函数
3. 在继承体系中把某些代码推上推下

如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性

### 重构的准备
重构前，先检查自己是否有一套可靠的测试集。<br>
这些测试集能降低你在重构时犯错的概率

### 重构的精髓
小步修改，每次修改后就运行测试。以微小的步伐修改程序，如果犯下错误，很容易就可以发现，这正是防止混乱的关键<br>

### 重构的性能问题
如果重构引入了性能损耗，先完成重构，再做性能优化。<br>
因为大多数重构之后（有了一份结构良好的代码）可以使用更高效的调优方案，最后得到的是既高效又整洁的代码。

### 重构与性能优化
相似之处：
两者都需要修改代码，并且两者都不会改变程序的整体功能<br><br>
区别：
1. 重构是为了让代码“更容易理解，更容易修改”，这可能使程序变得更快或慢
2. 性能优化时，只关注让程序运行得更快，这可能使得代码变得更难理解和维护

### 代码的坏味道 
1. 神秘命名。如果想不出一个好名字，说明背后很可能潜藏着更深的设计问题
2. 重复代码。设法将它们合而为一，程序会变得更好
3. 过长函数。函数越长，越难理解。分解过长函数也会带来经常切换上下文的弊端，所以关键还是在于良好的命名
4. 过长参数列表。使用类可以有效地缩短参数列表，或者可以以查询取代参数。
5. 全局变量。在代码库的任何一个角落都可以修改它，难以找到出错代码
6. 发散式变化。某个模块经常因为不同的原因在不同的方向上发生变化。对于不同的上下文，我们需要将它们搬至各自独立的模块。
7. 霰弹式修改。没遇到某种变化，需要在许多不同的类内做出许多小修改。
8. 依恋情结。一个函数与另一模块中的函数或者数据交流格外频繁
9. 数据泥团。很多地方出现相同的数据项，比如两个类中相同的字段、函数签名中相同的参数。
10. 基本类型偏执。不愿意创建对自己的问题域有用的基本类型，比如，电话号码不只是一串字符。
11. 重复的switch。



## 重构名录
### 1.提炼函数
> 动机：如果你需要花时间浏览一段代码才能弄清它在干嘛，那么就应该将其提炼到一个函数中，并根据它所做的事命名

### 2.内联函数
> 动机：某些函数内部代码和函数名称清晰易读，可以直接内联至调用函数。或者是一些组织不合理的函数，也可以先把它们内联，再提炼。

### 3.提炼变量
> 动机：表达式有可能非常复杂而难以阅读

### 4.内联变量
> 动机：这个变量并不比表达式本身更具表现力

### 5.改变函数声明
> 动机：函数名不恰当。选择恰当的参数列表，比如传入的参数为Cat，那么可以变为父类Animal，以去除不必要的耦合

### 6.封装变量
> 动机：如果变量被广泛使用

对于封装变量的一些错误使用，这篇文章讲得很好
https://dzone.com/articles/java-getter-and-setter-basics-common-mistakes-and

### 7.引入参数对象
> 动机：函数中总是出没一组相同的数据项(数据泥团)，可以用一个数据结构取代它

### 8.函数组合成类
> 动机：一组函数形影不离地操作同一块数据，通常是传参，那么可以把它们组成一个类。从而在对象内部调用时可以少传许多参数

### 9.函数组合成变换。
> 动机：把所有计算数据的逻辑收拢一处，这样始终可以在固定的地方找到和更新这些逻辑。

### 10.拆分阶段
> 动机：一段代码在处理两件不同的事

### 11.以查询取代临时变量
> 动机：适用于那些只被计算一次且之后不再被修改的变量。如果正在分解一个冗长的函数，那么将变量抽取到函数里能使函数的分解过程变得更简单.

### 12.提炼类
> 动机：一个维护大量函数和数据的类，这样的类往往太大而不易理解

### 13.内联类
> 动机：一个类不再承担足够责任，不再有单独存在的理由

### 14.隐藏委托关系
> 动机：如果客户端先通过服务对象的字段得到另一个对象(受托类)，然后调用后者的函数，那么客户端必须知晓这一层委托关系。可在服务对象上放置一个简单的委托函数，将委托关系隐藏起来。

### 15.移除中间人
> 动机：随着受托类的功能越来越多，服务类完成变成了一个中间人，此时就应该让客户直接调用受托类


## 编码风格
1. 将返回值命名为result，能一眼知道它的用途
2. 为参数取名时默认带上其类型名，类型Person，可取名为aPersion


