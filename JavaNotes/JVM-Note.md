* [一、Java内存区域](#一Java内存区域)
    * [1. 程序计数器](#1程序计数器)
    * [2. Java虚拟机栈](#2Java虚拟机栈)
    * [3. 本地方法栈](#3本地方法栈)
    * [4. Java堆](#4Java堆)
    * [5. 方法区](#5方法区)
    * [6. 元空间](#6元空间)
    * [7. 运行时常量池](#7运行时常量池)
    * [8. 直接内存](#8直接内存)
* [二、内存溢出与内存泄漏](#二内存溢出与内存泄漏)
    * [1. 内存溢出](#1内存溢出)
        * [I. 堆溢出](#I堆溢出)
        * [II. 虚拟机栈溢出](II虚拟机栈溢出)
        * [III. 方法区溢出](III方法区溢出)
        * [IV. 直接内存溢出](#直接内存溢出)
    * [2. 内存泄漏](#2内存泄漏)
        * [I. 四种引用](#I四种引用)
        * [II. 例子](#V例子)
* [三、对象的内存布局](#三对象的内存布局)
* [四、GC](#四GC)
    * [1. 如何判断对象是否需要回收](#1如何判断对象是否需要回收)
        * [I. 引用计数算法](#I引用计数算法)
        * [II. 可达性分析](#II可达性分析)
    * [2. GC算法](2GC算法)
        * [I. 标记清除算法](#I标记清除算法)
        * [II. 复制算法](#II复制算法)
        * [III. 标记整理算法](#III标记整理算法)
        * [IV. 分代收集算法](#IV分代收集算法)
    * [3. 垃圾收集器](3垃圾收集器)
        * [I. Serial收集器](#ISerial收集器)
        * [II. Serial Old收集器](#IISerialOld收集器)
        * [III. Parnew收集器](#IIIParnew收集器)
        * [IV. Parallel Scanvenge收集器](IVParallelScanvenge收集器)
        * [V. Parallel Old收集器](VParallelOld收集器)
        * [VI. CMS收集器](#VICMS收集器)
        * [VII. G1收集器](VIIG1收集器)
# 一、Java内存区域*
 ![Java内存区域](../docs/内存区域.jpg)
<br>

## 1.程序计数器

**定义：它可以看作当前线程所执行的字节码的行号指示器
<br>
它是*线程私有*的：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器**
<br/><br/>
作用：字节码解释器在工作时是通过改变这个计数器的值来选取下一条执行的字节码指令(分支、循环、异常处理、线程恢复都依赖计数器)<br/><br/>

Java方法：计数器记录的是正在执行的虚拟机字节码指令的地址<br>
Native方法：值为空（Undefined）<br><br>



## 2.Java虚拟机栈

**定义：描述了Java方法执行的内存模型，每个方法在执行的同时会创建一个*栈帧*，每个方法从调用直到执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
<br>
它是*线程私有*的：每条线程都有自己的虚拟机栈**
<br><br>

>栈帧：用于存储 局部变量表、操作数栈、动态链接、方法出口等信息<br><br>
>> 局部变量表：用于存放方法参数和方法内部定义的局部变量,boolean、char、short、int、float、reference(对象引用)、returnAddress(指向一条字节码指令的地址)，占一个局部变量空间，64位的long、double占两个。局部变量表所需的内存空间在编译期间完成分配，即方法需要在栈中分配多大的局部变量空间是完全确定的
<br><br>
>>操作数栈：是栈帧中一个后进先出的栈，刚创建栈帧是里面为空，方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。理论相互独立，但大多虚拟机会进行优化，令一部分数据进行栈帧共享，这样在方法调用的时候，无需进行额外的参数复制传递
<br><br>
>> 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，来支持动态链接的实现。符号引用（名字A）和直接引用（地址）在运行时进行解析和链接的过程，称为动态连接
<br><br>
>>方法出口：正常情况，调用者的PC计数器可以作为返回地址。异常退出，返回地址要通过异常处理器表来确定。退出操作：一、恢复上层方法的局部变量表和操作数栈。二、把返回值压入调用者调用者栈帧的操作数栈。 三、调整 PC 计数器的值以指向方法调用指令后面的一条指令。

<br><br>
## 3.本地方法栈
**定义：与虚拟机栈发挥的作用很相似,也是线程私有的**<br>
区别：虚拟机栈是为Java方法（字节码）服务的，本地方法栈是为虚拟机使用到的native方法服务的

<br><br>
## 4.Java堆

**定义：是虚拟机管理的内存中最大的一块，唯一目的就是存放对象实例，也是GC管理的主要区域，可以处于物理上不连续的内存空间**
<br>
由于现在收集器基本采用分代收集算法，所以堆还可以细分为新生代，老年代。
<br><br>

> 新生代：分为三个区域，一个Eden区和两个Survivor区，它们之间的默认比例为（8：1：1）
<br><br>
>老年代: 主要存放应用程序中生命周期长的内存对象
<br><br>
> TLAB：分配缓存区，由于堆是所有**线程共享**的，因此在堆上分配内存需要加锁。为了提高效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配


<br><br>
## 5.方法区

**定义：用于存储已被虚拟机加载的类信息、常量池、静态变量、符号引用，即时编译器编译后的代码等数据。（永久代是Hotspot虚拟机特有的概念，是方法区的一种实现）**
<br><br>
>类信息：1. 这个类的全限定名 &ensp;&ensp;2.这个类的直接父类的全限定名  &ensp;&ensp; 3. 该类实现的接口的全限定名的有序列表  &ensp;&ensp;  4.该类是类类型还是接口类型  &ensp;&ensp; 5.该类的修饰符

改动：1.在JDK1.7的HotSpot中，把字符串常量池从方法区中移出。<br>
    &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.在JDK1.8的HotSpot中，取消了方法区，在本地内存用元空间替代


<br><br>
## 6.元空间
**定义：元空间的本质和永久代类似，都是对JVM规范中方法区的实现，最大的区别是元空间使用的是本地内存**
<br><br>

**为什么要用元空间代替永久代？**<br>
一、字符串存在永久代中，容易出现性能问题和内存溢出<br>
二、类及方法的信息等比较难确定其大小，太小容易出现永久代溢出，太大容易导致老年代溢出<br>		  	
三、永久代会为 GC 带来不必要的复杂度且回收效率偏低


<br><br>
## 7.运行时常量池
**定义：Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。**
<br><br>
通俗点说，Java文件在编译成Class文件的时候，常量池里面的一些字面量和符号引用仅仅只是个名字而已，还没指向对应的内存地址，在类加载时会把这些字面量和符号引用放入运行时常量池并指向对应的内存地址

JDK 1.7的时候，字符串常量池从方法区中移至堆中<br>
JDK 1.8的时候，由于方法区的移除，运行时常量池也从方法区转移至了元空间


<br><br>
## 8.直接内存
**定义：在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配本地内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据**


<br><br>
# 二、内存溢出与内存泄漏
## 1. 内存溢出
内存溢出（OutOfMemoryError OOM），可以理解JVM在申请内存时，因为没有足够的内存提供而引发的错误
<br>
### I.堆溢出
出现堆溢出原因是为对象分配内存时，堆内存不足。<br>
具体原因如下:
>1. 为大对象分配内存，如大数组
>2. 低效率的GC，可能堆空间过小或存在内存泄漏。官方对效率低的定义为：超过98%的时间用来做GC并且回受了不到2%的堆内存
>3. 频繁地使用String.intern()。JDK 1.7以后的字符串常量池在堆中

常用参数：-Xms -Xmx （堆初始容量大小跟堆最大容量，如-Xms512m）
<br><br>

### II.虚拟机栈溢出
因为每条线程都会有虚拟机栈与之对应，因此当**运行线程数过多**或者**设置的栈过大**，都可能出现OOM
<br><br>
区别于StackOverflowError，这个错误一般发生在错误地递归，当线程请求栈深度大于虚拟机所允许的最大深度时(取决于-Xss)，将抛出StackOverflowError
<br><br>
常用参数：-Xss (栈容量大小)
<br><br>

### III.方法区溢出
对于方法区的溢出，要理解方法区存的东西是什么？它用于存储已被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码。所以在经常动态生成大量Class的应用中，要注意会不会出现OOM。
> 1. 应用中有大量的JSP。在JSP被第一次访问时，JSP引擎会将JSP转换编译成Class，并加入内存
> 2. 存在大量反射的场景。反射也会加载将Class进内存
> 3. JDK 1.7以前频繁地使用String.intern()。那时的字符串常量池还在方法区里

常用参数：<br>
1.7及之前，可以通过-XX:PermSize  -XX:PermSizeMax限制方法区大小
<br>
1.8:  -XX:MetaspaceSize   -XX:MaxMetaspaceSize 元空间初始与最大容量
<br><br>

### IV.直接内存溢出
这个一般是频繁使用NIO或NIO使用不当造成的，因为直接内存不像新生代跟老年代那样，发现空间不足就通知收集器回收垃圾，它只能在Full GC时清理需要回收的对象
<br><br>
内存大小可通过 -XX:MaxDirectMemorySize指定，默认与Java堆最大值相等(-Xmx)
<br><br>

## 2.内存泄漏
内存泄漏是指，一个对象不再被需要了，可是收集器却无法将它回收，因为存在引用链。ThreadLocal使用弱引用解决了Map中Key内存泄漏的问题，不过Value还是存在内存泄漏的可能
### I.强引用
强引用(Strong Reference)：类似“ Object obj = new Object()”这类的引用，只要还存在强引用，垃圾收集器就不会回收掉被引用的对象

### II.软引用
软引用(Soft Reference)：描述一些有用但非必需的对象。只有在内存不足的时候JVM才会回收该对象，用SoftReference类实现。
```java
Object obj = new Obejct(); 
SoftReference<Object> sf = new SoftReference<>(obj)
```
### III.弱引用
弱引用(Weak Reference)：也是描述非必需的对象，不过当垃圾收集器工作时，无论内存是否足够，都会回收被弱引用关联的对象。用WeakReference类实现，用法同上。适用于偶尔引用但不影响垃圾收集的对象

### IV.虚引用
虚引用(Phantom Reference)：最弱的一种关系引用。跟没有引用一样，随时都可能被回收，设置虚引用的唯一目的就是能在这个对象被回收时取得一个系统通知，用PhantomReference类实现。



# 三、对象的内存布局
 对象的内存区域可分为三个部分：对象头、实例数据、对齐填充
<br><br>
## 1.对象头
对象头又可分为两部分
<br>
> 一、用于存储对象自身的运行时数据，如哈希码、GC分代年龄、线程持有的锁、锁状态标志、偏向线程ID等
<br>

![对象头的运行时数据](../docs/对象头的运行数据.png)

> 二、类型指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

## 2.实例数据
实例数据是对象真正存储的有效信息，就是定义的各种类型的字段内容，包括父类继承下来的

## 3.对齐填充
仅仅起占位符的作用。因为HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以当实例数据部分没有对齐时，就通过对齐填充来补全。（对象头部分正好时8字节的1倍或2倍）


<br>

![对象内存](../docs/对象内存.png)

## 4.对象的访问定位
使用对象，一般是通过栈上的引用去操作堆中的对象，引用访问堆中的对象有两种方式：句柄和直接指针
>句柄：Java 堆中划分出一块区域来存储句柄，句柄中存储了对象的数据指针和类型指针。引用先访问句柄，在通过句柄存储的指针到具体的数据和类型。

<br><br>
>直接指针： 引用直接存储对象的数据指针，使用直接指针访问模式的堆实例数据，数据中包含了对象类型的指针。

![对象的定位](../docs/对象的定位.png)


<br><br>
句柄的好处是，当数据地址修改时，只需要修改句柄中的地址，引用本身不需要修改；直接指针的好处是速度更快。Hotspot 使用的是直接指针的方式访问对象。



<br><br>
# 四、GC
