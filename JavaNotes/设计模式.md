## 单例模式

### 1. 定义
保证一个类仅创建一个实例，并提供一个访问它的全局访问点

三要点：
1. 这个类只能有一个实例。
2. 它必须自行创建这个实例
3. 必须自行向整个系统提供这个实例

### 2. 优点

通过单例模式，我们可以避免多次创建多个实例，从而节约系统资源

### 3. 饿汉模式
```java
public class Singleton{

    private static Singleton singleton = new Singleton(); // 自行创建实例
    
    private Singleton(){} //构造函数私有化
    
    public static Singleton getInstance(){ //通过该函数向整个系统提供实例
        return singleton;
    }

}
```
被static修饰的成员变量会在类初始化过程中被收集进类构造器中(<clinit>)，在多线程场景下，JVM会保证只有一个线程能执行该类的<clinit>方法。

优点：可以在多线程的情况下实例的唯一性，而且全局访问点直接返回唯一实例，性能十分高

缺点：在类成员变量比较多或者变量比较大的情况下，该模式可能会在没有使用类对象的情况下，一直占用堆内存

### 4. 懒汉模式

为了避免直接加载类对象时提前创建对象的一种单例设计模式

```java

public class Singleton{
    
    private static Singleton singleton = null;

    private Singleton(){}

    public static Singleton getInstance(){
        if(singelton == null){
            singleton = new Singleton();
        }
        return singleton;
    }
}

```

达到了懒加载的效果，但是在多线程环境下，会出现实例化多个类对象的情况

#### Double-Check

```java
public class Singleton{

    private static volatile Singleton singleton = null;

    private Singleton(){}

    public static Singleton getInstance(){
    
        if( singleton == null ){
            synchronized (Singleton.class){
                if( singleton == null ){
                    singleton = new Singleton();
                }
        }
        return singleton;
    }
}
}
```
避免了线程不安全，同时也避免了不必要的开销


#### 静态内部类
```java

public class Singleton{
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        return InnerClass.INSTANCE;
    }

    private static class InnerClass{
        private static final Singleton INSTANCE = new Singleton();
    }
}
```
无线程同步问题，实现了懒加载。因为只有调用getInstance时才会装载内部类

#### 枚举
```java
public enum Singleton{
    
    INSTANCE;

    public void whatSoEverMethod(){}
    
    // 非必须，只是为了保证与其它方案一样使用静态方法得到实例
    public static Singleton getInstance(){
        return INSTANCE;
    }
}
```
枚举本身是线程安全的，且能防止通过反射和反序列化创建多实例


# 原型模式

## 定义
通过一个原型对象来指明所创建的对象的类型，然后使用自身实现的克隆接口来复制这个原型对象。
该模式就是用这种方式来创建出更多同类型的对象

## 优点
使用这种方式创建新的对象，就无需再通过new进行实例化。这是因为Object类的clone方法是一个本地方法，
它可以直接操作内存中的二进制流，所以性能相对new实例化更佳


## 实现
```java
class Prototype implements Cloneable{
    // 重写clone方法
    public Prototype clone(){
        Prototype prototype = null;
        try{
            prototype = (Prototype)super.clone();
        }catch (CloneNotSupportedException e){
            e.prinStackTrace();
        }
        return prototype;
    }
}

class ConcretePrototype extends Prototype{
    public void show(){
        System.out.println("原型模式实现类");
    }
}

public class Client { 
    public static void main(String[] args){ 
        ConcretePrototype cp = new ConcretePrototype();
        for( int i = 0; i < 10; i++){
            ConcretePrototype cloneCp = (ConcretePrototype) cp.clone();
            cloneCp.show();
        }
    }
}
        

```

需要具备三个条件才能实现一个原型类

- 实现Cloneable接口：它告诉虚拟机可以安全地在实现了这个接口的类上使用clone方法，否则拷贝的时候会发生异常
- 重写Object的clone方法
- 重写时调用super.clone()：默认情况下，类不具有复制对象的能力，需要通过这个方法实现

### 深拷贝与浅拷贝
简单地调用super.clone()是一种浅拷贝
> 1. 它首先会检查对象所属的类是否支持clone
> 2. 如果支持就创建当前对象所属类的一个新对象
> 3. 对该对象进行初始化，使得新对象的成员变量与当前对象的成员变量值一模一样

但是对于其它对象的引用以及List等类型的成员属性只能复制引用

深拷贝是基于浅拷贝来递归实现具体的每个对象


## 场景用途
在一些重复创建对象的场景下，我们就可以使用原型模式来提高对象的创建性能



# 享元模式

